"""
Defines a set of syntax examples producing *parsing errors*, recording the
generated parser exception and creating an ErrorPattern with a customized
error message.

Once these patterns are injected in the parser, when a similar error occurs
it will use the customized error message.

Use the -test switch to test the raw error generated by the parser for the 
given code.

    $ booi scripts/error-patterns.boo -test
    (1, (2   <<< press ctrl+d >>>

The -debug switch allows to parse the given snippet and output the first
syntax error found after applying all the patterns defined.

"""
# If it gets difficult to write specific rules, perhaps we can include
# some additional matchers that take into account the tokens in the scanner
# buffer for example.
# For more advanced stuff we may even inspect the partially generated AST
# at the time of the error. 
#

from System import Console, ConsoleColor
from System.IO import StringReader
from Boo.Lang.Parser import *
from Boo.Lang.Compiler.Ast import CompileUnit
from System.Collections.Generic import Stack, HashSet
from Boo.Lang.Compiler import Ast
import antlr from 'Boo.Lang.Parser.dll'


class GeneratorParser(BooParser):
""" Specialized parser for capturing and validating errors examples
"""
    Message as string
    CapturedPattern as ErrorPattern
    IsValidating = false
    Ignore = false

    def constructor(message as string, code as string):
        super(CreateBooLexer(4, '<generator>', StringReader(code)))
        Message = message

    def Capture(patterns):
        ErrorPatterns = patterns
        start(CompileUnit())
        return CapturedPattern

    def Validate(patterns):
        ErrorPatterns = patterns
        IsValidating = true

        cached_error as RecognitionException = null
        Error = def (ex as RecognitionException):
            cached_error = ex

        start(CompileUnit())
        return cached_error

    override def reportError(ex as RecognitionException, rulename as string):
        # Skip any other errors produced after the first one
        return if Ignore
        Ignore = true

        if IsValidating:
            super(ex, rulename)
            return

        if mismatch = ex as MismatchedTokenException:
            CapturedPattern = MismatchedErrorPattern(Message, rulename, mismatch.expecting)
        elif noviable = ex as NoViableAltException:
            CapturedPattern = NoViableAltErrorPattern(Message, rulename, noviable.token.Type)
        else:
            CapturedPattern = RecognitionErrorPattern(Message, rulename)


class AnyErrorPattern(ErrorPattern):
    property Exception as RecognitionException

    def constructor():
        super(null, null)

    override def Matches(rule as string, ex as RecognitionException):
        Rule = rule
        Exception = ex
        return true



PATTERNS = List[of ErrorPattern]()

def error(msg as string, code as string):
    indent = ' ' * 8

    for testcode in /^-{3,}/m.Split(code):
        testcode = testcode.Trim()

        lines = testcode.Split(char('\n'))
        comment = join(lines, '\n' + indent + '    // ')

        # Build error pattern from example code
        pattern = GeneratorParser(msg, testcode).Capture(null)
        if not pattern:
            raise "ERROR: The following snippet did not produce any errors!\n$testcode"
        PATTERNS.Add(pattern)

        # Validate the pattern when actually used with the others
        ex = GeneratorParser(msg, testcode).Validate(PATTERNS.ToArray())
        if not ex:
            raise "ERROR: Validation for the following snippet did not produce any errors!\n$testcode"

        if msg != ex.Message:
            Console.ForegroundColor = ConsoleColor.Yellow
            Console.Error.WriteLine("expected: $msg")
            Console.Error.WriteLine("produced: $(ex.Message)")
            Console.Error.WriteLine('  ' + testcode.Replace("\n", "\n  "))
            Console.Error.WriteLine()
            Console.ResetColor()


if len(argv) and argv[0] == '-test':
    code = ''
    while null != (ln = Console.ReadLine()):
        code += ln + "\n"

    any = AnyErrorPattern()
    ex = GeneratorParser('<test>', code).Validate(List[of ErrorPattern]() { any })
    if not ex:
        print "No error generated from the snippet"
        return

    print 'Rule:', any.Rule
    print 'Exception:', any.Exception
    return



#####################################################################
## Error examples. Order them to disambiguate
#####################################################################

error "Unbalanced expression, closing paren not found", """
a = (bar, baz
def foo():
    pass
---
a = (bar, baz
---
foo(
---
foo(bar, baz
qux
---
class Foo(Bar:
    pass
"""

error "Unbalanced expression, opening paren not found", """
foo)
---
foo = a, b)
---
def fn():
    foo)
"""

error "Either separate expressions with commas or make sure your parens are balanced", """
foo(bar baz, qux)
"""

error "Expressions must be separated by commas", """
foo(bar baz)
---
a = foo bar
"""
# error "Expressions must be separated by commas", """
# print foo bar
# """

error "Block must be indented", """
def foo():
return
---
block:
return
---
while true:
return
---
class Foo
    pass
---
class Foo(Bar)
    pass
"""


#####################################################################
## Code generation
#####################################################################

if len(argv) and argv[0] == '-debug':
    code = ''
    while null != (ln = Console.ReadLine()):
        code += ln + "\n"

    ex = GeneratorParser('<debug>', code).Validate(PATTERNS)
    if not ex:
        print "No error generated from the snippet"
        return

    print ex
    return


print """
// DO NOT EDIT! File automatically generated from parser error examples

namespace Boo.Lang.Parser
{
    static class GeneratedErrorPatterns
    {
        public static readonly ErrorPattern[] Patterns = {
"""

level = 3
def indent(*parts as (string)):
    ind = '    ' * level
    text = ind + join(parts, '').Replace('\n', '\n' + ind)
    print text

for i as int, pattern as ErrorPattern in enumerate(PATTERNS):
    indent pattern.ToCodeString(), (',\n' if i < len(PATTERNS) - 1 else '')

print """   
        };
    }
}
"""
